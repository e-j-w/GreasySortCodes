#include "common.h" //define all global variables here!

//function which generates a mapping between ordering parameters and real spatial coordinates
//and saves this mapping to disk
void generate_mapping(const char *infile, const char *simfile, const char *calfile, const char *outfile) {

  TList * list = new TList;

  //setup density functions for the real spatial coordinates r, angle, and z in cylindrical coordinates
  //these are read in from a ROOT tree generated by a GEANT4 simulation such as G4TIP
  TH1D *rDistHist[NSEG], *angleDistHist[NSEG*MAX_VAL_R/BIN_WIDTH_R], *zDistHist[NSEG*(MAX_VAL_R/BIN_WIDTH_R)*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)];
  char hname[32];
  for(int k = 0; k < NSEG; k++){
    sprintf(hname,"rDistSeg%i",k);
    rDistHist[k] = new TH1D(hname,Form("rDistSeg%i",k),40,0,MAX_VAL_R);
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      sprintf(hname,"angleDistSeg%ir%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R);
      angleDistHist[k*MAX_VAL_R/BIN_WIDTH_R + j] = new TH1D(hname,Form("angleDistSeg%ir%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R),30,0,MAX_VAL_ANGLE);
      for(int i = 0; i < MAX_VAL_ANGLE/BIN_WIDTH_ANGLE; i++){
        sprintf(hname,"zDistSeg%ir%ito%iangle%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R,i*BIN_WIDTH_ANGLE,(i+1)*BIN_WIDTH_ANGLE);
        zDistHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = new TH1D(hname,Form("zDistSeg%ir%ito%iangle%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R,i*BIN_WIDTH_ANGLE,(i+1)*BIN_WIDTH_ANGLE),90,0,90);
      }
    }
  }

  TTree *simTree;
  TFile *inp = new TFile(simfile,"read");
  if((simTree = (TTree*)inp->Get("tree"))==NULL){
    cout << "ERROR: No spatial coordinate distribution info in the specified ROOT file!" << endl;
    exit(-1);
  }
  TBranch *rBranch, *phiBranch, *zBranch, *segIDBranch;
  TLeaf *rLeaf, *phiLeaf, *zLeaf, *segIDLeaf;
  if((rBranch = simTree->GetBranch("TigressSegmentMaxECylr"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxECylr' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    rLeaf = (TLeaf*)rBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }
  if((phiBranch = simTree->GetBranch("TigressSegmentMaxECylphi"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxECylphi' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    phiLeaf = (TLeaf*)phiBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }
  if((zBranch = simTree->GetBranch("TigressSegmentMaxECylz"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxECylz' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    zLeaf = (TLeaf*)zBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }
  if((segIDBranch = simTree->GetBranch("TigressSegmentMaxEId"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxEId' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    segIDLeaf = (TLeaf*)segIDBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }

  Int_t sentries = simTree->GetEntries();
  Double_t rVal, angleVal, zVal;
  Int_t idVal;
  for (int i=0;i<sentries;i++){
    simTree->GetEntry(i);
    for(int j=0; j<rLeaf->GetNdata(); j++) { //deal with multiple fold events
      if((rLeaf->GetNdata()==phiLeaf->GetNdata())&&((rLeaf->GetNdata()==zLeaf->GetNdata()))&&(rLeaf->GetNdata()==segIDLeaf->GetNdata())){
        rVal = rLeaf->GetValue(j);
        angleVal = phiLeaf->GetValue(j)*180./M_PI;
        zVal = zLeaf->GetValue(j);
        idVal = segIDLeaf->GetValue(j)-1; //convert to zero-indexed
        if((idVal>=0)&&(idVal<NSEG)){
          rDistHist[idVal]->Fill(rVal);
          if((rVal>=0)&&(rVal<=MAX_VAL_R)){ 
            Int_t rInd = (Int_t)(rVal/BIN_WIDTH_R);
            angleDistHist[idVal*MAX_VAL_R/BIN_WIDTH_R + rInd]->Fill(angleVal*180./M_PI);
            if((angleVal>=0)&&(angleVal<=MAX_VAL_ANGLE)){
              Int_t angleInd = (Int_t)(angleVal/BIN_WIDTH_ANGLE);
              zDistHist[idVal*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + rInd*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + angleInd]->Fill(zVal);
            }
          }
        }else{
          cout << "Sim tree: invalid segment." << endl;
        }
      }else{
        cout << "Sim tree: data size mismatch." << endl;
      }

    }
  }

  //normalize distributions and get cumulative versions
  TH1 *rDistHistC[NSEG], *angleDistHistC[NSEG*MAX_VAL_R/BIN_WIDTH_R], *zDistHistC[NSEG*(MAX_VAL_R/BIN_WIDTH_R)*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)];
  for(int k = 0; k < NSEG; k++){
    rDistHist[k]->Scale(1.0/rDistHist[k]->Integral());
    rDistHistC[k] = rDistHist[k]->GetCumulative();
    list->Add(rDistHist[k]);
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      angleDistHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->Scale(1.0/angleDistHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->Integral());
      angleDistHistC[k*MAX_VAL_R/BIN_WIDTH_R + j] = angleDistHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->GetCumulative();
      list->Add(angleDistHist[k*MAX_VAL_R/BIN_WIDTH_R + j]);
      for(int i = 0; i < MAX_VAL_ANGLE/BIN_WIDTH_ANGLE; i++){
        zDistHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->Scale(1.0/zDistHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->Integral());
        zDistHistC[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = zDistHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->GetCumulative();
        list->Add(zDistHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]);
      }
    }
  }

  cout << "Spatial parameter distributions read in." << endl;

  //setup a histogram for the ordering parameters
  //ROOT histograms are used to store this data since ROOT provides useful
  //methods such as GetCumulative() and GetQuantiles() which will be used later
  //TH3D is used to preverse correlated values of rho, phi, zeta, 
  //will handle the individual mapping of the parameters later
  TH3D *rhophizetaHist[NSEG];
  for(int k = 0; k < NSEG; k++){
    sprintf(hname,"rhophizetaSeg%i",k);
    rhophizetaHist[k] = new TH3D(hname,Form("rhophizetaSeg%i",k),N_BINS_ORDERING,-1.*RHO_MAX,1.*RHO_MAX,N_BINS_ORDERING,-1.*PHI_MAX,1.*PHI_MAX,N_BINS_ORDERING,-1.*ZETA_MAX,1.*ZETA_MAX);
    //list->Add(rhophizetaHist[k]);
  }

  TFile * inputfile = new TFile(infile, "READ");
  if (!inputfile->IsOpen()) {
    cout << "ERROR: Could not open analysis tree file!" << endl;
    exit(-1);
  }
  TChain * AnalysisTree = (TChain * ) inputfile->Get("AnalysisTree");
  cout << AnalysisTree->GetNtrees() << " tree files, details:" << endl;
  AnalysisTree->ls();
  TTree * tree = (TTree * ) AnalysisTree->GetTree();
  cout << "Reading calibration file: " << calfile << endl;
  TChannel::ReadCalFile(calfile);
  Int_t nentries = AnalysisTree->GetEntries();

  TTigress * tigress = 0;
  TTigressHit * tigress_hit;
  if (AnalysisTree->FindBranch("TTigress")) {
    AnalysisTree->SetBranchAddress("TTigress", & tigress);
  } else {
    cout << "ERROR: no TTigress branch found!" << endl;
    exit(-1);
  }

  Int_t samples = 100; //number of samples per waveform

  Int_t hit_counter = 0;
  Int_t map_hit_counter = 0;
  Int_t overflow_rho_counter = 0;
  Int_t overflow_phi_counter = 0;
  Int_t overflow_zeta_counter = 0;

  const std::vector<Short_t> *wf, *segwf, *segwf2, *segwf3;
  bool found1, found2;
  Int_t waveform_t0;
  Int_t one;
  Int_t offset = 0;
  for (int jentry = 0; jentry < tree->GetEntries(); jentry++) {
    tree->GetEntry(jentry);
    for (one = 0; one < tigress->GetMultiplicity(); one++) {
      tigress_hit = tigress->GetTigressHit(one);
      if(tigress_hit->GetKValue() != 700) continue;
      tigress_hit->SetWavefit();
      wf = tigress_hit->GetWaveform();
      samples = wf->size();
      TPulseAnalyzer pulse;
      pulse.SetData(*wf,0);  // Allows you to use the full TPulseAnalyzer class
      waveform_t0 = (Int_t)pulse.fit_newT0(); //in samples
      if((waveform_t0 <= 0)||(waveform_t0 >= samples-WAVEFORM_SAMPLING_WINDOW -1)){
        //this entry has an unusable risetime
        continue;
      }
      hit_counter++;
      bool isHit = false;
      for(int i = 0; i < tigress_hit->GetSegmentMultiplicity(); i++)
      {

        
        TGRSIDetectorHit segment_hit = tigress_hit->GetSegmentHit(i);

        Int_t segNum = segment_hit.GetSegment()-1; //1-indexed from GRSIsort, convert to 0-indexed

        //calculate all ordering parameters (see ordering_parameter_calc.cxx)
        Double_t rho = calc_ordering(tigress_hit,i,jentry,samples,waveform_t0,0);
        if(rho == BAD_RETURN){
          continue;
        }
        Double_t phi = calc_ordering(tigress_hit,i,jentry,samples,waveform_t0,1);
        if(phi == BAD_RETURN){
          continue;
        }
        Double_t zeta = calc_ordering(tigress_hit,i,jentry,samples,waveform_t0,2);
        if(zeta == BAD_RETURN){
          continue;
        }

        if(fabs(rho) > RHO_MAX)
          overflow_rho_counter++;
        if(fabs(phi) > PHI_MAX)
          overflow_phi_counter++;
        if(fabs(zeta) > ZETA_MAX)
          overflow_zeta_counter++;
        
        //cout << "seg: " << segNum << ", rho: " << rho << ", phi:" << phi << ", zeta: " << zeta << endl;
        //cout << "bin: " << rhophizetaHist[segNum]->GetBin(rho,phi,zeta) << endl;
        rhophizetaHist[segNum]->Fill(rho,phi,zeta);
        isHit = true;
      }
      if(isHit){
        map_hit_counter++;
      }
    }
    if (jentry % 10000 == 0) cout << setiosflags(ios::fixed) << "Entry " << jentry << " of " << nentries << ", " << 100 * jentry / nentries << "% complete" << "\r" << flush;
  }

  cout << "Entry " << nentries << " of " << nentries << ", 100% Complete!" << endl;
  cout << map_hit_counter << " of " << hit_counter << " hits retained (" << 100*map_hit_counter/hit_counter << " %)." << endl;
  cout << "Hits with ordering parameters out of map range for [rho, phi, zeta]: [" << overflow_rho_counter << " " << overflow_phi_counter << " " << overflow_zeta_counter << "]" << endl;

  //generate normalized cumulative distributions of all ordering parameters,
  //and then ordering parameter to spatial coordinate maps
  Double_t xVal[1], qVal[1];
  Int_t nQuantiles;

  //first we map rho on a per segment basis
  cout << "Mapping ordering parameter rho to radius spatial parameter..." << endl;
  //generate cumulative distributions
  TH1 *rhoHist[NSEG], *rhoHistC[NSEG];
  for(int k = 0; k < NSEG; k++){
    rhoHist[k] = new TH1D();
    rhoHist[k] = rhophizetaHist[k]->ProjectionX();
    if(rhoHist[k]->GetEntries()>0){
      rhoHist[k]->Scale(1.0/rhoHist[k]->Integral());
      rhoHistC[k] = rhoHist[k]->GetCumulative();
      rhoHistC[k]->SetNameTitle(Form("rhoHistCumulativeSeg%i",k),Form("rhoHistCumulativeSeg%i",k));
      list->Add(rhoHistC[k]);
    }
  }
  //generate maps
  TH1 *rMap[NSEG];
  for(int k = 0; k < NSEG; k++){
    if(rhoHist[k]->GetEntries()>0){
      sprintf(hname,"rMapSeg%i",k);
      rMap[k] = new TH1D(hname,Form("rMapSeg%i",k),N_BINS_ORDERING,-1.*RHO_MAX,1.*RHO_MAX);
      for(int l=0;l<N_BINS_ORDERING;l++){
        xVal[0] = rhoHistC[k]->GetBinContent(l+1);
        nQuantiles = rDistHist[k]->GetQuantiles(1,qVal,xVal);
        if(nQuantiles==1){
          rMap[k]->SetBinContent(l+1,qVal[0]);
        }
      }
      list->Add(rMap[k]);
    }
  }
  //store rho bin numbers which correspond to discrete values of r
  Int_t rhoBinVal[NSEG*(MAX_VAL_R/BIN_WIDTH_R + 1)];
  for(int k = 0; k < NSEG; k++){
    for(int j = 0; j <= MAX_VAL_R/BIN_WIDTH_R; j++){
      rhoBinVal[k*MAX_VAL_R/BIN_WIDTH_R + j] = rMap[k]->FindFirstBinAbove(j*BIN_WIDTH_R);
    }
  }

  //now map phi based on mapped radius (binned) and segment number
  cout << "Mapping ordering parameter phi to angle spatial parameter..." << endl;
  //generate cumulative distributions
  TH1 *phiHist[NSEG*MAX_VAL_R/BIN_WIDTH_R], *phiHistC[NSEG*MAX_VAL_R/BIN_WIDTH_R];
  for(int k = 0; k < NSEG; k++){
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      //get the projection in phi (y) gated on a range in rho (x)
      phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j] = new TH1D();
      phiHistC[k*MAX_VAL_R/BIN_WIDTH_R + j] = new TH1D();
      Int_t lowerBound = rhoBinVal[k*MAX_VAL_R/BIN_WIDTH_R + j];
      Int_t upperBound = rhoBinVal[k*MAX_VAL_R/BIN_WIDTH_R + j + 1];
      if((lowerBound > 0)&&(lowerBound < upperBound)){
        //cout << "bin: " << j << ", proj bounds: " << lowerBound << " " << upperBound << endl;
        phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j] = rhophizetaHist[k]->ProjectionY("",lowerBound,upperBound);
        if(phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->GetEntries()>0){
          phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->Scale(1.0/phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->Integral());
          phiHistC[k*MAX_VAL_R/BIN_WIDTH_R + j] = phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->GetCumulative();
          phiHistC[k*MAX_VAL_R/BIN_WIDTH_R + j]->SetNameTitle(Form("phiHistCumulativeSeg%ir%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R),Form("phiHistCumulativeSeg%ir%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R));
          list->Add(phiHistC[k*MAX_VAL_R/BIN_WIDTH_R + j]);
        }
      }
    }
  }
  //generate maps
  TH1 *angleMap[NSEG*MAX_VAL_R/BIN_WIDTH_R];
  for(int k = 0; k < NSEG; k++){
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      sprintf(hname,"angleMapSeg%ir%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R);
      angleMap[k*MAX_VAL_R/BIN_WIDTH_R + j] = new TH1D(hname,Form("angleMapSeg%ir%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R),N_BINS_ORDERING,-1.0*PHI_MAX,PHI_MAX);
      if(phiHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->GetEntries()>0){
        for(int l=0;l<N_BINS_ORDERING;l++){
          xVal[0] = phiHistC[k*MAX_VAL_R/BIN_WIDTH_R + j]->GetBinContent(l+1);
          nQuantiles = angleDistHist[k*MAX_VAL_R/BIN_WIDTH_R + j]->GetQuantiles(1,qVal,xVal);
          if(nQuantiles==1){
            angleMap[k*MAX_VAL_R/BIN_WIDTH_R + j]->SetBinContent(l+1,qVal[0]);
          }
        }
        list->Add(angleMap[k*MAX_VAL_R/BIN_WIDTH_R + j]);
      }
    }
  }
  //store bin numbers which correspond to discrete values of the angle
  Int_t phiBinVal[NSEG*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + 1)*(MAX_VAL_R/BIN_WIDTH_R)];
  for(int k = 0; k < NSEG; k++){
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      for(int i = 0; i <= MAX_VAL_ANGLE/BIN_WIDTH_ANGLE; i++){
        //printf("k j i %i %i %i\n",k,j,i);
        //printf("bins %i %i\n",k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i, k*MAX_VAL_R/BIN_WIDTH_R + j);
        phiBinVal[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = angleMap[k*MAX_VAL_R/BIN_WIDTH_R + j]->FindFirstBinAbove(i*BIN_WIDTH_ANGLE);
        //printf("k j i %i %i %i, binVal: %i\n",k,j,i,phiBinVal[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]);
      }
    }
  }

  //now map zeta based on mapped radius and angle (both binned) and segment number
  cout << "Mapping ordering parameter zeta to depth spatial parameter..." << endl;
  //generate cumulative distributions
  TH1 *zetaHist[NSEG*(MAX_VAL_R/BIN_WIDTH_R)*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)], *zetaHistC[NSEG*(MAX_VAL_R/BIN_WIDTH_R)*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)];
  for(int k = 0; k < NSEG; k++){
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      Int_t lowerBoundx = rhoBinVal[k*MAX_VAL_R/BIN_WIDTH_R + j];
      Int_t upperBoundx = rhoBinVal[k*MAX_VAL_R/BIN_WIDTH_R + j + 1];
      for(int i = 0; i < MAX_VAL_ANGLE/BIN_WIDTH_ANGLE; i++){
        //get the projection in zeta (z) gated on a range in rho (x) and phi (y)
        zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = new TH1D();
        zetaHistC[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = new TH1D();
        Int_t lowerBoundy = phiBinVal[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i];
        Int_t upperBoundy = phiBinVal[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i + 1];
        //cout << "bin: " << k << " " << j << " " << i << ", proj bounds x: " << lowerBoundx << " " << upperBoundx << endl;
        //cout << "proj bounds y: " << lowerBoundy << " " << upperBoundy << endl;
        if((lowerBoundx > 0)&&(lowerBoundx < upperBoundx)){
          if((lowerBoundy > 0)&&(lowerBoundy < upperBoundy)){
            zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = rhophizetaHist[k]->ProjectionZ("",lowerBoundx,upperBoundx,lowerBoundy,upperBoundy);
            if(zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->GetEntries()>0){
              zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->Scale(1.0/zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->Integral());
              zetaHistC[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->GetCumulative();
              zetaHistC[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->SetNameTitle(Form("zetaHistCumulativeSeg%ir%ito%iangle%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R,i*BIN_WIDTH_ANGLE,(i+1)*BIN_WIDTH_ANGLE),Form("zetaHistCumulativeSeg%ir%ito%iangle%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R,i*BIN_WIDTH_ANGLE,(i+1)*BIN_WIDTH_ANGLE));
              list->Add(zetaHistC[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]);
            }
          }
        }
      }
    }
  }
  //generate maps
  TH1 *zMap[NSEG*(MAX_VAL_R/BIN_WIDTH_R)*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)];
  for(int k = 0; k < NSEG; k++){
    for(int j = 0; j < MAX_VAL_R/BIN_WIDTH_R; j++){
      for(int i = 0; i < MAX_VAL_ANGLE/BIN_WIDTH_ANGLE; i++){
        //cout << "bin: " << k << " " << j << " " << i << endl;
        if(zetaHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->GetEntries()>0){
          sprintf(hname,"zMapSeg%ir%ito%iangle%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R,i*BIN_WIDTH_ANGLE,(i+1)*BIN_WIDTH_ANGLE);
          zMap[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i] = new TH1D(hname,Form("zMapSeg%ir%ito%iangle%ito%i",k,j*BIN_WIDTH_R,(j+1)*BIN_WIDTH_R,i*BIN_WIDTH_ANGLE,(i+1)*BIN_WIDTH_ANGLE),N_BINS_ORDERING,-1.*ZETA_MAX,1.*ZETA_MAX);
          for(int l=0;l<N_BINS_ORDERING;l++){
            xVal[0] = zetaHistC[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->GetBinContent(l+1);
            nQuantiles = zDistHist[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->GetQuantiles(1,qVal,xVal);
            if(nQuantiles==1){
              zMap[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]->SetBinContent(l+1,qVal[0]);
            }
          }
          list->Add(zMap[k*(MAX_VAL_ANGLE/BIN_WIDTH_ANGLE)*(MAX_VAL_R/BIN_WIDTH_R) + j*MAX_VAL_ANGLE/BIN_WIDTH_ANGLE + i]);
        }
      }
    }
  }

  cout << "Writing histograms to: " << outfile << endl;
  TFile * myfile = new TFile(outfile, "RECREATE");
  myfile->cd();
  list->Write();
  cout << "Histograms written, mapping complete!" << endl;
  myfile->Close();
  inp->Close();
}

int main(int argc, char ** argv) {

  const char *afile, *simfile, *outfile, *calfile;

  // Input-chain-file, output-histogram-file
  if (argc < 3) {
    cout << endl << "This sortcode makes a map for the gamma tracking direct method which transforms ordering parameters to real spatial coordinates.  ";
    cout << "These maps are constructed from real calibration data (which should be provided in the analysis tree, the first argument), and simulated distributions of the ";
    cout << "spatial coordinates (which should be provided in a ROOT tree, the second argument).  GEANT4 simulations exist which can produce the simulated distribution data ";
    cout << "(for example, G4TIP (https://github.com/e-j-w/G4TIP/))." << endl << endl;
    cout << "Arguments: ./GammaTrackingMakeMap analysis_tree_file sim_tree_file cal_file output_file" << endl;
    cout << "The analysis tree and simulation tree are required arguments.  Omitting other arguments will cause the sortcode to fall back to default values." << endl << endl;
    cout << "NOTE: this code requires a LOT of memory (around 10GB with N_BINS_ORDERING set to 512 in common.h, scaling as N_BINS_ORDERING^3) to run." << endl << endl;
	  return 0;
  } else if (argc == 3) {
	  afile = argv[1];
    simfile = argv[2];
	  calfile = "CalibrationFile.cal";
	  outfile = "trackingMap.root";
  } else if (argc == 4) {
	  afile = argv[1];
    simfile = argv[2];
	  calfile = argv[3];
	  outfile = "trackingMap.root";
  } else if (argc == 5) {
	  afile = argv[1];
    simfile = argv[2];
	  calfile = argv[3];
	  outfile = argv[4];
  } else if (argc > 5) {
	  cout << "Too many arguments." << endl;
    cout << "Arguments: ./GammaTrackingMakeMap analysis_tree_file sim_tree_file cal_file output_file" << endl;
	  return 0;
  }

  cout << "Starting sortcode..." << endl;

  std::string grsi_path = getenv("GRSISYS"); // Finds the GRSISYS path to be used by other parts of the grsisort code
  if(grsi_path.length() > 0) {
	  grsi_path += "/";
  }
  // Read in grsirc in the GRSISYS directory to set user defined options on grsisort startup
  grsi_path += ".grsirc";
  gEnv->ReadFile(grsi_path.c_str(), kEnvChange);

  cout << "Input file: " << afile << endl << "Simulation data file: " << simfile << endl << "Calibration file: " << calfile << endl << "Output file: " << outfile << endl;

  TParserLibrary::Get()->Load();

  generate_mapping(afile, simfile, calfile, outfile);

  return 0;
}
