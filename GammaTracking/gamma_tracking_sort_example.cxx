#include "GammaTrackingTIGRESS.h" //define all global variables here!

TH3D *pos3DMap, *pos3DMapClover, *pos3DMapAbs;
TH2D *posXYMapBottom, *posXYMapTop, *posXZMap, *posYZMap;
TH2D *posXYMapBottom137Cs, *posXYMapTop137Cs, *posXZMap137Cs, *posYZMap137Cs;
TH1D *rHist, *phiHistBottom, *phiHistTop, *zHist;
TH1D *tigE, *dopplerESeg, *dopplerEGT;
GT_map *trackingMap;

void sortData(TFile *inputfile, const char *calfile){
  TChain * AnalysisTree = (TChain * ) inputfile->Get("AnalysisTree");
  cout << AnalysisTree->GetNtrees() << " tree files, details:" << endl;
  AnalysisTree->ls();
  TTree * tree = (TTree * ) AnalysisTree->GetTree();
  cout << "Reading calibration file: " << calfile << endl;
  TChannel::ReadCalFile(calfile);
  Int_t nentries = AnalysisTree->GetEntries();

  TTigress * tigress = 0;
  TTigressHit * tigress_hit;
  if (AnalysisTree->FindBranch("TTigress")) {
    AnalysisTree->SetBranchAddress("TTigress", & tigress);
  } else {
    cout << "ERROR: no TTigress branch found!" << endl;
    exit(-1);
  }

  Int_t hit_counter = 0;
  Int_t sort_hit_counter = 0;

  TVector3 recoil_vec;
  recoil_vec.SetX(0.); recoil_vec.SetY(0.); recoil_vec.SetZ(1.);
  double beta = 0.05;

  Int_t one;
  for (int jentry = 0; jentry < tree->GetEntries(); jentry++) {
    tree->GetEntry(jentry);
    for (one = 0; one < tigress->GetMultiplicity(); one++) {
      tigress_hit = tigress->GetTigressHit(one);
      if(tigress_hit->GetKValue() != 700) continue;
      hit_counter++;
      TVector3 posVec = GT_get_pos_direct(tigress_hit,trackingMap);
      if(posVec.X()!=BAD_RETURN){
        //cout << "Filling: " << posVec.X() << " " << posVec.Y() << " " << posVec.Z() << endl;
        pos3DMap->Fill(posVec.X(),posVec.Y(),posVec.Z());
        rHist->Fill(posVec.Perp());
        zHist->Fill(posVec.Z());
        TVector3 posVecAbs = GT_transform_position_to_absolute(tigress_hit,&posVec);
        pos3DMapAbs->Fill(posVecAbs.X(),posVecAbs.Y(),posVecAbs.Z());
        TVector3 posVecClover = GT_transform_position_to_clover(tigress_hit,&posVec);
        pos3DMapClover->Fill(posVecClover.X(),posVecClover.Y(),posVecClover.Z());
        if(posVec.Z() <= 30.){
          phiHistBottom->Fill(posVec.Theta());
          posXYMapBottom->Fill(posVec.X(),posVec.Y());
        }else{
          phiHistTop->Fill(posVec.Theta());
          posXYMapTop->Fill(posVec.X(),posVec.Y());
        }
        posXZMap->Fill(posVec.X(),posVec.Z());
        posYZMap->Fill(posVec.Y(),posVec.Z());
        //map positions of hits corresponding to 137Cs photopeak
        if((tigress_hit->GetEnergy() > 659)&&(tigress_hit->GetEnergy() < 664)){
          if(posVec.Z() <= 30.){
            posXYMapBottom137Cs->Fill(posVec.X(),posVec.Y());
          }else{
            posXYMapTop137Cs->Fill(posVec.X(),posVec.Y());
          }
          posXZMap137Cs->Fill(posVec.X(),posVec.Z());
          posYZMap137Cs->Fill(posVec.Y(),posVec.Z());
        }
        double egt = GT_get_doppler(beta,&recoil_vec,tigress_hit,&posVec);
        if(egt>5.){
          dopplerEGT->Fill(egt);
        }
        sort_hit_counter++;
      }
      double eseg = tigress_hit->GetDoppler(beta,&recoil_vec);
      if(eseg>5.){
        dopplerESeg->Fill(eseg);
        tigE->Fill(tigress_hit->GetEnergy());
      }
    }
    if (jentry % 10000 == 0) cout << setiosflags(ios::fixed) << "Entry " << jentry << " of " << nentries << ", " << 100 * jentry / nentries << "% complete" << "\r" << flush;
  }

  cout << "Entry " << nentries << " of " << nentries << ", 100% Complete!" << endl;
  cout << sort_hit_counter << " of " << hit_counter << " hits retained (" << 100*sort_hit_counter/hit_counter << " %)." << endl;
}


//function which maps hit positions using a map file generated by the GammaTrackingMakeMap code
void sort_test(const char *infile, const char *mapfile, const char *calfile, const char *outfile, bool inpList) {

  //read in histograms from map file
  trackingMap = (GT_map*)malloc(sizeof(GT_map));
  TFile *mapInp = new TFile(mapfile,"read");
  GT_import_map(mapInp,trackingMap);
  
  //setup output histograms
  TList * list = new TList;
  pos3DMap = new TH3D("pos3DMap","Core Position Map",40,-40,40,40,-40,40,40,-10,100);
  list->Add(pos3DMap);
  pos3DMapClover = new TH3D("pos3DMapClover","Clover Positon Map",80,-80,80,80,-80,80,40,-10,100);
  list->Add(pos3DMapClover);
  pos3DMapAbs = new TH3D("pos3DMapAbsolute","Absolute Positon Map",40,-300,300,40,-300,300,40,-300,300);
  list->Add(pos3DMapAbs);
  posXYMapBottom = new TH2D("posXYMapSeg0-3","posXYMapSeg0-3",40,-40,40,40,-40,40);
  list->Add(posXYMapBottom);
  posXYMapTop = new TH2D("posXYMapSeg4-7","posXYMapSeg4-7",40,-40,40,40,-40,40);
  list->Add(posXYMapTop);
  posXZMap = new TH2D("posXZMap","posXZMap",40,-40,90,40,-10,100);
  list->Add(posXZMap);
  posYZMap = new TH2D("posYZMap","posYZMap",40,-40,90,40,-10,100);
  list->Add(posYZMap);
  posXYMapBottom137Cs = new TH2D("posXYMapSeg0-3 - 137Cs full energy","posXYMapSeg0-3 - 137Cs full energy",40,-40,40,40,-40,40);
  list->Add(posXYMapBottom137Cs);
  posXYMapTop137Cs = new TH2D("posXYMapSeg4-7 - 137Cs full energy","posXYMapSeg4-7 - 137Cs full energy",40,-40,40,40,-40,40);
  list->Add(posXYMapTop137Cs);
  posXZMap137Cs = new TH2D("posXZMap - 137Cs full energy","posXZMap - 137Cs full energy",40,-40,90,40,-10,100);
  list->Add(posXZMap137Cs);
  posYZMap137Cs = new TH2D("posYZMap - 137Cs full energy","posYZMap - 137Cs full energy",40,-40,90,40,-10,100);
  list->Add(posYZMap137Cs);
  rHist = new TH1D("rHist","hit radius",500,0,50);
  list->Add(rHist);
  phiHistBottom = new TH1D("phiHistSeg0-3","hit phi segment 0-3",500,-2.*M_PI,2.*M_PI);
  list->Add(phiHistBottom);
  phiHistTop = new TH1D("phiHistSeg4-7","hit phi segment 4-7",500,-2.*M_PI,2.*M_PI);
  list->Add(phiHistTop);
  zHist = new TH1D("zHist","hit z",500,0,100);
  list->Add(zHist);
  tigE = new TH1D("tigE","TIGRESS energy (uncorrected)",16384,0,4096);
  list->Add(tigE);
  dopplerESeg = new TH1D("dopplerESeg","Doppler Corrected Energy (segment position)",16384,0,4096);
  list->Add(dopplerESeg);
  dopplerEGT = new TH1D("dopplerEGT","Doppler Corrected Energy (tracked position)",16384,0,4096);
  list->Add(dopplerEGT);

  //sort data from individual analysis tree or list of trees
  if(inpList){
    FILE *listFile;
    char name[256];
    if((listFile=fopen(infile,"r"))==NULL){
      cout << "ERROR: Could not open analysis tree list file!" << endl;
      exit(-1);
    }
    while(fscanf(listFile,"%s",name)!=EOF){
      TFile * inputfile = new TFile(name, "READ");
      if (!inputfile->IsOpen()) {
        cout << "ERROR: Could not open analysis tree file (" << name << ")" << endl;
        exit(-1);
      }
      sortData(inputfile, calfile);
      inputfile->Close();
    }
    fclose(listFile);
  }else{
    TFile * inputfile = new TFile(infile, "READ");
    if (!inputfile->IsOpen()) {
      cout << "ERROR: Could not open analysis tree file (" << infile << ")" << endl;
      exit(-1);
    }
    sortData(inputfile, calfile);
    inputfile->Close();
  }

  

  cout << "Writing histograms to: " << outfile << endl;
  TFile * myfile = new TFile(outfile, "RECREATE");
  myfile->cd();
  list->Write();
  cout << "Histograms written, sorting complete!" << endl;
  myfile->Close();
  mapInp->Close();
}

int main(int argc, char ** argv) {

  const char *afile, *mapfile, *calfile, *outfile;
  char *ext;

  if (argc < 2) {
    cout << endl << "This sortcode sorts resconstructed hit positions, using the map file generated using the GammaTrackingMakeMap code.  ";
    cout << "It is only suitable for events containing a single interaction in a single segment, use the GammaTrackingSortFromBasis code otherwise." << endl << endl;
    cout << "Arguments: ./GammaTrackingSortExample analysis_tree_file map_file cal_file output_file" << endl << endl;
    cout << "The analysis tree (containing the experimental data to be sorted) is a required argument.  Omitting other arguments will cause the sortcode to fall back to default values." << endl << endl;
	  return 0;
  } else if (argc == 2) {
	  afile = argv[1];
    mapfile = "trackingMap.root";
	  calfile = "CalibrationFile.cal";
	  outfile = "trackingSortTest.root";
  } else if (argc == 3) {
	  afile = argv[1];
    mapfile = argv[2];
	  calfile = "CalibrationFile.cal";
	  outfile = "trackingSortTest.root";
  } else if (argc == 4) {
	  afile = argv[1];
    mapfile = argv[2];
	  calfile = argv[3];
	  outfile = "trackingSortTest.root";
  } else if (argc == 5) {
	  afile = argv[1];
    mapfile = argv[2];
	  calfile = argv[3];
	  outfile = argv[4];
  } else if (argc > 5) {
	  cout << "Too many arguments." << endl;
    cout << "Arguments: ./GammaTrackingSortExample analysis_tree_file map_file cal_file output_file" << endl;
	  return 0;
  }

  cout << "Starting sortcode..." << endl;

  std::string grsi_path = getenv("GRSISYS"); // Finds the GRSISYS path to be used by other parts of the grsisort code
  if(grsi_path.length() > 0) {
	  grsi_path += "/";
  }
  // Read in grsirc in the GRSISYS directory to set user defined options on grsisort startup
  grsi_path += ".grsirc";
  gEnv->ReadFile(grsi_path.c_str(), kEnvChange);

  cout << "Input file: " << afile << endl << "Map data file: " << mapfile << endl << "Calibration file: " << calfile << endl << "Output file: " << outfile << endl;

  TParserLibrary::Get()->Load();

  ext=strrchr(argv[1],'.'); /* returns a pointer to the last . to grab extention*/

  if(strcmp(ext,".list")==0){
    cout << "Sorting from a list of analysis trees..." << endl;
    sort_test(afile, mapfile, calfile, outfile, true);
  }else{
    cout << "Sorting from a single analysis tree..." << endl;
    sort_test(afile, mapfile, calfile, outfile, false);
  }

  return 0;
}
