#include <iostream>
#include <iomanip>
#include "TCutG.h"
#include "TH1.h"
#include "TF1.h"
#include "TTree.h"
#include "TLeaf.h"
#include "TChain.h"
#include "TH2.h"
#include "TFile.h"
#include "TGraphErrors.h"
#include "TDirectory.h"
#include "TList.h"
#include "TRandom.h"
#include "TTigress.h"
#include "TGriffin.h"
#include "TGRSIDetectorHit.h"
#include "TGRSIDetectorInformation.h"
#include "TSpectrum.h"
#include "TChannel.h"
#include "TPulseAnalyzer.h"
#include "TParserLibrary.h"
#include "TEnv.h"

using namespace std;

#define     NPOS   16 //number of positions in the array
#define     NCORE  4  //number of cores per position
#define     NSEG   8  //number of segments per core

#define     N_BINS_ORDERING 2048 //number of bins to use when discretizing ordering parameter

//lists of adjacent segments in the TIGRESS array (zero-indexed)
Int_t phiAdjSeg1[8] = {3,0,1,2,7,4,5,6};
Int_t phiAdjSeg2[8] = {1,2,3,0,5,6,7,4};
Int_t    zAdjSeg[8] = {4,5,6,7,0,1,2,3};

//function which generates a mapping between ordering parameters and real spatial coordinates
//and saves this mapping to disk
void generate_mapping(const char *infile, const char *simfile, const char *calfile, const char *outfile) {

  TList * list = new TList;

  //setup density functions for the real spatial coordinates r, angle, and z in cylindrical coordinates
  //these are read in from a ROOT tree generated by a GEANT4 simulation such as G4TIP
  TH1D *rDistHist[NSEG], *angleDistHist[NSEG], *zDistHist[NSEG];
  char hname[20];
  for(int k = 0; k < NSEG; k++){
    sprintf(hname,"rDistSeg%i",k);
    rDistHist[k] = new TH1D(hname,Form("rDistSeg%i",k),40,0,40);
    sprintf(hname,"angleDistSeg%i",k);
    angleDistHist[k] = new TH1D(hname,Form("angleDistSeg%i",k),30,0,90);
    sprintf(hname,"zDistSeg%i",k);
    zDistHist[k] = new TH1D(hname,Form("zDistSeg%i",k),90,0,90);
  }

  TTree *simTree;
  TFile *inp = new TFile(simfile,"read");
  if((simTree = (TTree*)inp->Get("tree"))==NULL){
    cout << "ERROR: No spatial coordinate distribution info in the specified ROOT file!" << endl;
    exit(-1);
  }
  TBranch *rBranch, *phiBranch, *zBranch, *segIDBranch;
  TLeaf *rLeaf, *phiLeaf, *zLeaf, *segIDLeaf;
  if((rBranch = simTree->GetBranch("TigressSegmentMaxECylr"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxECylr' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    rLeaf = (TLeaf*)rBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }
  if((phiBranch = simTree->GetBranch("TigressSegmentMaxECylphi"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxECylphi' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    phiLeaf = (TLeaf*)phiBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }
  if((zBranch = simTree->GetBranch("TigressSegmentMaxECylz"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxECylz' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    zLeaf = (TLeaf*)zBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }
  if((segIDBranch = simTree->GetBranch("TigressSegmentMaxEId"))==NULL){
    cout << "ERROR: Sort data path 'TigressSegmentMaxEId' doesn't correspond to a branch or leaf in the tree!" << endl;
    exit(-1);
  }else{
    segIDLeaf = (TLeaf*)segIDBranch->GetListOfLeaves()->First(); //get the first leaf from the specified branch       
  }

  Int_t sentries = simTree->GetEntries();
  Double_t rVal, angleVal, zVal;
  Int_t idVal;
  for (int i=0;i<sentries;i++){
    simTree->GetEntry(i);
    for(int j=0; j<rLeaf->GetNdata(); j++) { //deal with multiple fold events
      if((rLeaf->GetNdata()==phiLeaf->GetNdata())&&((rLeaf->GetNdata()==zLeaf->GetNdata()))&&(rLeaf->GetNdata()==segIDLeaf->GetNdata())){
        rVal = rLeaf->GetValue(j);
        angleVal = phiLeaf->GetValue(j);
        zVal = zLeaf->GetValue(j);
        idVal = segIDLeaf->GetValue(j)-1; //convert to zero-indexed
        if((idVal>=0)&&(idVal<NSEG)){
          rDistHist[idVal]->Fill(rVal);
          angleDistHist[idVal]->Fill(angleVal*180./M_PI);
          zDistHist[idVal]->Fill(zVal);
        }else{
          cout << "Sim tree: invalid segment." << endl;
        }
      }else{
        cout << "Sim tree: data size mismatch." << endl;
      }

    }
  }

  //normalize distributions and get cumulative versions
  TH1 *rDistHistC[NSEG], *angleDistHistC[NSEG], *zDistHistC[NSEG];
  for(int k = 0; k < NSEG; k++){
    rDistHist[k]->Scale(1.0/rDistHist[k]->Integral());
    angleDistHist[k]->Scale(1.0/angleDistHist[k]->Integral());
    zDistHist[k]->Scale(1.0/zDistHist[k]->Integral());
    rDistHistC[k] = rDistHist[k]->GetCumulative();
    angleDistHistC[k] = angleDistHist[k]->GetCumulative();
    zDistHistC[k] = zDistHist[k]->GetCumulative();
  }

  //setup list to write to file
  for(int k = 0; k < NSEG; k++){
    if(rDistHist[k]->GetEntries() > 0){
      list->Add(rDistHist[k]);
      list->Add(angleDistHist[k]);
      list->Add(zDistHist[k]);
    }
  }
  for(int k = 0; k < NSEG; k++){
    if(rDistHistC[k]->GetEntries() > 0){
      list->Add(rDistHistC[k]);
      list->Add(angleDistHistC[k]);
      list->Add(zDistHistC[k]);
    }
  }
  

  cout << "Spatial parameter distributions read in." << endl;

  //setup histograms for the ordering parameters
  //ROOT histograms are used to store this data since ROOT provides useful
  //methods such as GetCumulative() and GetQuantiles() which will be used later
  TH1D *rhoHist[NPOS*NCORE*NSEG], *phiHist[NPOS*NCORE*NSEG], *zetaHist[NPOS*NCORE*NSEG];
  for(int i = 0; i < NPOS; i++){
    for(int j = 0; j < NCORE; j++){
      for(int k = 0; k < NSEG; k++){
        sprintf(hname,"rhoPos%iCore%iSeg%i",i,j,k);
        rhoHist[NCORE*NSEG*i + NSEG*j + k] = new TH1D(hname,Form("rhoPos%iCore%iSeg%i",i,j,k),N_BINS_ORDERING,-2048,2048);
        sprintf(hname,"phiPos%iCore%iSeg%i",i,j,k);
        phiHist[NCORE*NSEG*i + NSEG*j + k] = new TH1D(hname,Form("phiPos%iCore%iSeg%i",i,j,k),N_BINS_ORDERING,-0.1,0.1);
        sprintf(hname,"zetaPos%iCore%iSeg%i",i,j,k);
        zetaHist[NCORE*NSEG*i + NSEG*j + k] = new TH1D(hname,Form("zetaPos%iCore%iSeg%i",i,j,k),N_BINS_ORDERING,-0.1,0.1);
        //list->Add(rhoHist[NCORE*NSEG*i + NSEG*j + k]);
        //list->Add(phiHist[NCORE*NSEG*i + NSEG*j + k]);
        //list->Add(zetaHist[NCORE*NSEG*i + NSEG*j + k]);
      }
    } 
  }

  TFile * inputfile = new TFile(infile, "READ");
  if (!inputfile->IsOpen()) {
    cout << "ERROR: Could not open analysis tree file!" << endl;
    exit(-1);
  }
  TChain * AnalysisTree = (TChain * ) inputfile->Get("AnalysisTree");
  cout << AnalysisTree->GetNtrees() << " tree files, details:" << endl;
  AnalysisTree->ls();
  TTree * tree = (TTree * ) AnalysisTree->GetTree();
  cout << "Reading calibration file: " << calfile << endl;
  TChannel::ReadCalFile(calfile);
  Int_t nentries = AnalysisTree->GetEntries();

  TTigress * tigress = 0;
  TTigressHit * tigress_hit, * tigress_hit2;
  if (AnalysisTree->FindBranch("TTigress")) {
    AnalysisTree->SetBranchAddress("TTigress", & tigress);
  } else {
    cout << "ERROR: no TTigress branch found!" << endl;
    exit(-1);
  }

  Int_t samples = 100; //number of samples per waveform
  Int_t sampling_window = 10; //number of waveform samples used to construct ordering parameters

  Int_t hit_counter = 0;
  Int_t map_hit_counter = 0;

  const std::vector<Short_t> *wf, *segwf, *segwf2, *segwf3;
  bool found1, found2;
  Int_t waveform_t0;
  Int_t one;
  Int_t offset = 0;
  for (int jentry = 0; jentry < tree->GetEntries(); jentry++) {
    tree->GetEntry(jentry);
    for (one = 0; one < tigress->GetMultiplicity(); one++) {
      tigress_hit = tigress->GetTigressHit(one);
      if(tigress_hit->GetKValue() != 700) continue;
      tigress_hit->SetWavefit();
      wf = tigress_hit->GetWaveform();
      samples = wf->size();
      TPulseAnalyzer pulse;
      pulse.SetData(*wf,0);  // Allows you to use the full TPulseAnalyzer class
      waveform_t0 = (Int_t)pulse.fit_newT0(); //in samples
      if((waveform_t0 <= 0)||(waveform_t0 >= samples-sampling_window-1)){
        //this entry has an unusable risetime
        continue;
      }
      for(int i = 0; i < tigress_hit->GetSegmentMultiplicity(); i++)
      {

        hit_counter++;
        TGRSIDetectorHit segment_hit = tigress_hit->GetSegmentHit(i);

        Int_t posNum = tigress_hit->GetDetector()-1;
        Int_t coreNum = tigress_hit->GetCrystal();
        Int_t segNum = segment_hit.GetSegment()-1; //1-indexed from GRSIsort, convert to 0-indexed

        //cout << "Entry " << jentry << ", position: " << posNum << ", core: " << coreNum << ", segment: " << segNum << endl;
        segwf = segment_hit.GetWaveform();
        if((posNum < 0)||(posNum > 15)){
          cout << "Entry " << jentry << ", invalid array position: " << posNum << endl;
          continue;
        }
        if(segwf->size() != samples){
          cout << "Entry " << jentry << ", mismatched waveform sizes." << endl;
          continue;
        }

        //construct rho, the ordering parameter for the radius
        //see Eq. 4 of NIM A 729 (2013) 198-206
        double sampleAvg = 0.;
        double rho = 0.;
        double dno = 0.; //placeholder for denominator
        for(int j=0;j<sampling_window;j++){
          sampleAvg += waveform_t0+j;
          dno += (segwf->at(waveform_t0+j+1) - segwf->at(waveform_t0+j-1))/2.0;
        }
        sampleAvg /= sampling_window*1.0;
        for(int j=0;j<sampling_window;j++){
          rho += pow(waveform_t0+j - sampleAvg,3.0)*(segwf->at(waveform_t0+j+1) - segwf->at(waveform_t0+j-1))/2.0;
        }
        rho /= dno;
        if(rho!=rho){
          cout << "Entry " << jentry << ", cannot compute rho parameter (NaN)." << endl;
          continue;
        }

        //contruct phi, the ordering parameter for the angle
        //see Eq. 3 of NIM A 729 (2013) 198-206
        double phi = 0.;
        found1 = false;
        found2 = false;
        for(int j = 0; j < tigress_hit->GetSegmentMultiplicity(); j++){
          if(tigress_hit->GetSegmentHit(j).GetSegment()-1 == phiAdjSeg1[segNum]){
            found1=true;
            segwf = tigress_hit->GetSegmentHit(j).GetWaveform();
          }
          if(tigress_hit->GetSegmentHit(j).GetSegment()-1 == phiAdjSeg2[segNum]){
            found2=true;
            segwf2 = tigress_hit->GetSegmentHit(j).GetWaveform();
          }
        }
        if((!found1)||(!found2)){
          cout << "Entry " << jentry << ", cannot get neighbouring segment wavefoms to compute phi parameter." << endl;
          cout << "Entry " << jentry << ", position: " << posNum << ", core: " << coreNum << ", segment: " << segNum << endl;
          continue;
        }else if((segwf->size() != samples)||(segwf2->size() != samples)){
          cout << "Entry " << jentry << ", mismatched waveform sizes." << endl;
          continue;
        }
        for(int j=0;j<sampling_window;j++){
          phi += segwf->at(waveform_t0+j)*segwf->at(waveform_t0+j) - segwf2->at(waveform_t0+j)*segwf2->at(waveform_t0+j);
          dno += segwf->at(waveform_t0+j)*segwf->at(waveform_t0+j) + segwf2->at(waveform_t0+j)*segwf2->at(waveform_t0+j);
        }
        phi /= dno;
        if(phi!=phi){
          cout << "Entry " << jentry << ", cannot compute phi parameter (NaN)." << endl;
          continue;
        }

        //contruct zeta, the ordering parameter for the z direction
        //see Eq. 2 of NIM A 729 (2013) 198-206 (modified here)
        double zeta = 0.;
        found1 = false;
        for(int j = 0; j < tigress_hit->GetSegmentMultiplicity(); j++){
          if(tigress_hit->GetSegmentHit(j).GetSegment()-1 == zAdjSeg[segNum]){
            found1=true;
            segwf3 = tigress_hit->GetSegmentHit(j).GetWaveform();
          }
        }
        if(!found1){
          cout << "Entry " << jentry << ", cannot get neighbouring segment wavefoms to compute zeta parameter." << endl;
          cout << "Entry " << jentry << ", position: " << posNum << ", core: " << coreNum << ", segment: " << segNum << endl;
          continue;
        }else if(segwf3->size() != samples){
          cout << "Entry " << jentry << ", mismatched waveform sizes." << endl;
          continue;
        }
        for(int j=0;j<sampling_window;j++){
          zeta += 2.0*segwf3->at(waveform_t0+j)*segwf3->at(waveform_t0+j) - segwf2->at(waveform_t0+j)*segwf2->at(waveform_t0+j) - segwf->at(waveform_t0+j)*segwf->at(waveform_t0+j);
          dno += 2.0*segwf3->at(waveform_t0+j)*segwf3->at(waveform_t0+j) + segwf2->at(waveform_t0+j)*segwf2->at(waveform_t0+j) + segwf->at(waveform_t0+j)*segwf->at(waveform_t0+j);
        }
        zeta /= dno;
        if(zeta!=zeta){
          cout << "Entry " << jentry << ", cannot compute zeta parameter (NaN)." << endl;
          continue;
        }

        if(segNum>3){
          //back segment, reverse sign to make zeta increase with z
          zeta *= -1.;
        }

        map_hit_counter++;
        rhoHist[NCORE*NSEG*posNum + NSEG*coreNum + segNum]->Fill(rho);
        phiHist[NCORE*NSEG*posNum + NSEG*coreNum + segNum]->Fill(phi);
        zetaHist[NCORE*NSEG*posNum + NSEG*coreNum + segNum]->Fill(zeta);

      }
    }
    if (jentry % 10000 == 0) cout << setiosflags(ios::fixed) << "Entry " << jentry << " of " << nentries << ", " << 100 * jentry / nentries << "% complete" << "\r" << flush;
  }

  cout << "Entry " << nentries << " of " << nentries << ", 100% Complete!" << endl;
  cout << map_hit_counter << " of " << hit_counter << " hits retained (" << 100*map_hit_counter/hit_counter << " %)." << endl;

  //generate normalized cumulative distributions of all ordering parameters
  cout << "Generating cumulative distributions of ordering parameters..." << endl;
  TH1 *rhoHistC[NPOS*NCORE*NSEG], *phiHistC[NPOS*NCORE*NSEG], *zetaHistC[NPOS*NCORE*NSEG];
  for(int i = 0; i < NPOS; i++){
    for(int j = 0; j < NCORE; j++){
      for(int k = 0; k < NSEG; k++){
        if(rhoHist[NCORE*NSEG*i + NSEG*j + k]->GetEntries()>0){
          rhoHist[NCORE*NSEG*i + NSEG*j + k]->Scale(1.0/rhoHist[NCORE*NSEG*i + NSEG*j + k]->Integral());
          rhoHistC[NCORE*NSEG*i + NSEG*j + k] = rhoHist[NCORE*NSEG*i + NSEG*j + k]->GetCumulative();
          list->Add(rhoHistC[NCORE*NSEG*i + NSEG*j + k]);
        }
        if(phiHist[NCORE*NSEG*i + NSEG*j + k]->GetEntries()>0){
          phiHist[NCORE*NSEG*i + NSEG*j + k]->Scale(1.0/phiHist[NCORE*NSEG*i + NSEG*j + k]->Integral());
          phiHistC[NCORE*NSEG*i + NSEG*j + k] = phiHist[NCORE*NSEG*i + NSEG*j + k]->GetCumulative();
          list->Add(phiHistC[NCORE*NSEG*i + NSEG*j + k]);
        }
        if(zetaHist[NCORE*NSEG*i + NSEG*j + k]->GetEntries()>0){
          zetaHist[NCORE*NSEG*i + NSEG*j + k]->Scale(1.0/zetaHist[NCORE*NSEG*i + NSEG*j + k]->Integral());
          zetaHistC[NCORE*NSEG*i + NSEG*j + k] = zetaHist[NCORE*NSEG*i + NSEG*j + k]->GetCumulative();
          list->Add(zetaHistC[NCORE*NSEG*i + NSEG*j + k]);
        }
      }
    } 
  }

  //generate ordering parameter to spatial coordinate maps
  cout << "Generating ordering parameter to spatial coordinate maps..." << endl;
  Double_t xVal[1], qVal[1];
  Int_t nQuantiles;
  TH1 *rMap[NPOS*NCORE*NSEG], *angleMap[NPOS*NCORE*NSEG], *zMap[NPOS*NCORE*NSEG];
  for(int i = 0; i < NPOS; i++){
    for(int j = 0; j < NCORE; j++){
      for(int k = 0; k < NSEG; k++){
        if(rhoHist[NCORE*NSEG*i + NSEG*j + k]->GetEntries()>0){
          sprintf(hname,"rMapPos%iCore%iSeg%i",i,j,k);
          rMap[NCORE*NSEG*i + NSEG*j + k] = new TH1D(hname,Form("rMapPos%iCore%iSeg%i",i,j,k),N_BINS_ORDERING,-2048,2048);
          for(int l=0;l<N_BINS_ORDERING;l++){
            xVal[0] = rhoHistC[NCORE*NSEG*i + NSEG*j + k]->GetBinContent(l+1);
            nQuantiles = rDistHist[k]->GetQuantiles(1,qVal,xVal);
            if(nQuantiles==1){
              rMap[NCORE*NSEG*i + NSEG*j + k]->SetBinContent(l+1,qVal[0]);
            }
          }
          list->Add(rMap[NCORE*NSEG*i + NSEG*j + k]);
        }
        if(phiHist[NCORE*NSEG*i + NSEG*j + k]->GetEntries()>0){
          sprintf(hname,"angleMapPos%iCore%iSeg%i",i,j,k);
          angleMap[NCORE*NSEG*i + NSEG*j + k] = new TH1D(hname,Form("angleMapPos%iCore%iSeg%i",i,j,k),N_BINS_ORDERING,-0.1,0.1);
          for(int l=0;l<N_BINS_ORDERING;l++){
            xVal[0] = phiHistC[NCORE*NSEG*i + NSEG*j + k]->GetBinContent(l+1);
            nQuantiles = angleDistHist[k]->GetQuantiles(1,qVal,xVal);
            if(nQuantiles==1){
              angleMap[NCORE*NSEG*i + NSEG*j + k]->SetBinContent(l+1,qVal[0]);
            }
          }
          list->Add(angleMap[NCORE*NSEG*i + NSEG*j + k]);
        }
        if(zetaHist[NCORE*NSEG*i + NSEG*j + k]->GetEntries()>0){
          sprintf(hname,"zMapPos%iCore%iSeg%i",i,j,k);
          zMap[NCORE*NSEG*i + NSEG*j + k] = new TH1D(hname,Form("zMapPos%iCore%iSeg%i",i,j,k),N_BINS_ORDERING,-0.1,0.1);
          for(int l=0;l<N_BINS_ORDERING;l++){
            xVal[0] = zetaHistC[NCORE*NSEG*i + NSEG*j + k]->GetBinContent(l+1);
            nQuantiles = zDistHist[k]->GetQuantiles(1,qVal,xVal);
            if(nQuantiles==1){
              zMap[NCORE*NSEG*i + NSEG*j + k]->SetBinContent(l+1,qVal[0]);
            }
          }
          list->Add(zMap[NCORE*NSEG*i + NSEG*j + k]);
        }
      }
    } 
  }

  cout << "Writing histograms to: " << outfile << endl;
  TFile * myfile = new TFile(outfile, "RECREATE");
  myfile->cd();
  list->Write();
  cout << "Histograms written, mapping complete!" << endl;
  myfile->Close();
  inp->Close();
}

int main(int argc, char ** argv) {

  const char *afile, *simfile, *outfile, *calfile;

  // Input-chain-file, output-histogram-file
  if (argc < 3) {
    cout << endl << "This sortcode makes a map for the gamma tracking direct method which transforms ordering parameters to real spatial coordinates.  ";
    cout << "These maps are constructed from real calibration data (which should be provided in the analysis tree, the first argument), and simulated distributions of the ";
    cout << "spatial coordinates (which should be provided in a ROOT tree, the second argument).  GEANT4 simulations exist which can produce the simulated distribution data ";
    cout << "(for example, G4TIP (https://github.com/e-j-w/G4TIP/))." << endl << endl;
    cout << "Arguments: ./GammaTrackingMakeMap analysis_tree_file sim_tree_file cal_file output_file" << endl;
    cout << "The analysis tree and simulation tree are required arguments.  Omitting other arguments will cause the sortcode to fall back to default values." << endl << endl;
	  return 0;
  } else if (argc == 3) {
	  afile = argv[1];
    simfile = argv[2];
	  calfile = "CalibrationFile.cal";
	  outfile = "trackingMap.root";
  } else if (argc == 4) {
	  afile = argv[1];
    simfile = argv[2];
	  calfile = argv[3];
	  outfile = "trackingMap.root";
  } else if (argc == 5) {
	  afile = argv[1];
    simfile = argv[2];
	  calfile = argv[3];
	  outfile = argv[4];
  } else if (argc > 5) {
	  cout << "Too many arguments." << endl;
    cout << "Arguments: ./GammaTrackingMakeMap analysis_tree_file sim_tree_file cal_file output_file" << endl;
	  return 0;
  }

  cout << "Starting sortcode..." << endl;

  std::string grsi_path = getenv("GRSISYS"); // Finds the GRSISYS path to be used by other parts of the grsisort code
  if(grsi_path.length() > 0) {
	  grsi_path += "/";
  }
  // Read in grsirc in the GRSISYS directory to set user defined options on grsisort startup
  grsi_path += ".grsirc";
  gEnv->ReadFile(grsi_path.c_str(), kEnvChange);

  cout << "Input file: " << afile << endl << "Simulation data file: " << simfile << endl << "Calibration file: " << calfile << endl << "Output file: " << outfile << endl;

  TParserLibrary::Get()->Load();

  generate_mapping(afile, simfile, calfile, outfile);

  return 0;
}
