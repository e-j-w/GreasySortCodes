#include "common.h" //define all global variables here!

TH1 *rMap[NSEG], *angleMap[NSEG*VOXEL_BINS_R], *zMap[NSEG*(VOXEL_BINS_R)*(VOXEL_BINS_ANGLE_MAX)];
TH1D *rMappedHist[NSEG], *angleMappedHist[NSEG], *zMappedHist[NSEG];
TH3D *pos3DMap;

void sortData(TFile *inputfile, const char *calfile){
  TChain * AnalysisTree = (TChain * ) inputfile->Get("AnalysisTree");
  cout << AnalysisTree->GetNtrees() << " tree files, details:" << endl;
  AnalysisTree->ls();
  TTree * tree = (TTree * ) AnalysisTree->GetTree();
  cout << "Reading calibration file: " << calfile << endl;
  TChannel::ReadCalFile(calfile);
  Int_t nentries = AnalysisTree->GetEntries();

  TTigress * tigress = 0;
  TTigressHit * tigress_hit;
  if (AnalysisTree->FindBranch("TTigress")) {
    AnalysisTree->SetBranchAddress("TTigress", & tigress);
  } else {
    cout << "ERROR: no TTigress branch found!" << endl;
    exit(-1);
  }

  Int_t hit_counter = 0;
  Int_t map_hit_counter = 0;

  Int_t one;
  for (int jentry = 0; jentry < tree->GetEntries(); jentry++) {
    tree->GetEntry(jentry);
    for (one = 0; one < tigress->GetMultiplicity(); one++) {
      tigress_hit = tigress->GetTigressHit(one);
      if(tigress_hit->GetKValue() != 700) continue;
      hit_counter++;
      bool isHit = false;
      for(int i = 0; i < tigress_hit->GetSegmentMultiplicity(); i++){

        //calculate all ordering parameters (see ordering_parameter_calc.cxx)
        double rho = calc_ordering(tigress_hit,i,jentry,0);
        if(rho == BAD_RETURN){
          continue;
        }
        double phi = calc_ordering(tigress_hit,i,jentry,1);
        if(phi == BAD_RETURN){
          continue;
        }
        double zeta = calc_ordering(tigress_hit,i,jentry,2);
        if(zeta == BAD_RETURN){
          continue;
        }

        isHit = true;

        Int_t segNum = tigress_hit->GetSegmentHit(i).GetSegment()-1; //1-indexed from GRSIsort, convert to 0-indexed

        //here is where the mapping happens
        double r=-1.;
        double angle=-1.;
        double z=-1.;
        if(rMap[segNum]!=NULL){
          r = rMap[segNum]->GetBinContent(rMap[segNum]->FindBin(rho));
        }
        Int_t rInd = (Int_t)(r*VOXEL_BINS_R/MAX_VAL_R);
        if(rInd < VOXEL_BINS_R){
          if(angleMap[segNum*VOXEL_BINS_R + rInd]!=NULL){
            angle = angleMap[segNum*VOXEL_BINS_R + rInd]->GetBinContent(angleMap[segNum*VOXEL_BINS_R + rInd]->FindBin(phi));
            if(angle>=MAX_VAL_ANGLE){
              angle=MAX_VAL_ANGLE-0.001; //have seen rare events where angle is exactly 90 degrees
            }
            Int_t angleInd = (Int_t)(angle*getNumAngleBins(rInd,1.0)/(MAX_VAL_ANGLE*1.0));
            //cout << "seg: " << segNum << ", r index: " << rInd << ", angle: " << angle << ", angle index: " << angleInd << ", num angle bins: " << getNumAngleBins(rInd,1.0) << endl;
            if(zMap[segNum*(VOXEL_BINS_ANGLE_MAX)*(VOXEL_BINS_R) + rInd*VOXEL_BINS_ANGLE_MAX + angleInd]!=NULL){
              z = zMap[segNum*(VOXEL_BINS_ANGLE_MAX)*(VOXEL_BINS_R) + rInd*VOXEL_BINS_ANGLE_MAX + angleInd]->GetBinContent(zMap[segNum*(VOXEL_BINS_ANGLE_MAX)*(VOXEL_BINS_R) + rInd*VOXEL_BINS_ANGLE_MAX + angleInd]->FindBin(zeta));
              if(z>=MAX_VAL_Z){
                z=MAX_VAL_Z-0.001; //have seen rare events where z is exactly 90 mm
              }

              if((r>0.)&&(z>0.)&&(angle>0.)){
                if(segNum<=3){
                  //r corresponds to the distance from the central contact at z=30
                  r = sqrt(r*r - (30.-z)*(30.-z));
                }
                if((r==r)&&(angle==angle)&&(z==z)){
                  rMappedHist[segNum]->Fill(r);
                  angleMappedHist[segNum]->Fill(angle);
                  zMappedHist[segNum]->Fill(z);
                  angle += 90.0*(segNum%4);
                  //if(z<20)
                    pos3DMap->Fill(r*cos(angle*M_PI/180.),r*sin(angle*M_PI/180.),z);
                  //cout << "r: " << r << ", angle: " << angle << ", z: " << z << endl;
                  /*if(r==0.){
                    cout << "rho: " << rho << endl;
                  }
                  cout << "x: " << r*cos(angle*M_PI/180.) << ", y: " << r*sin(angle*M_PI/180.) << ", z: " << z << endl;*/
                }
              }
            }
          }
        }
      }
      if(isHit){
        map_hit_counter++;
      }
    }
    if (jentry % 10000 == 0) cout << setiosflags(ios::fixed) << "Entry " << jentry << " of " << nentries << ", " << 100 * jentry / nentries << "% complete" << "\r" << flush;
  }

  cout << "Entry " << nentries << " of " << nentries << ", 100% Complete!" << endl;
  cout << map_hit_counter << " of " << hit_counter << " hits retained (" << 100*map_hit_counter/hit_counter << " %)." << endl;
}


//function which maps hit positions using a map file generated by the GammaTrackingMakeMap code
void sort_test(const char *infile, const char *mapfile, const char *calfile, const char *outfile, bool inpList) {

  TList * list = new TList;

  //read in histograms from map file
  TFile *inp = new TFile(mapfile,"read");
  if (!inp->IsOpen()) {
    cout << "ERROR: Could not open map file!" << endl;
    exit(-1);
  }else{
    cout << "Opened map file: " << mapfile << endl;
  }

  
  for(int k = 0; k < NSEG; k++){
    sprintf(hname,"rMapSeg%i",k);
    if((rMap[k] = (TH1*)inp->Get(hname))==NULL){
      cout << "No r coordinate map for segment " << k << endl;
    }
    for(int j = 0; j < VOXEL_BINS_R; j++){
      Int_t rValMin = (Int_t)(j*(MAX_VAL_R/(VOXEL_BINS_R*1.0)));
      Int_t rValMax = (Int_t)((j+1)*(MAX_VAL_R/(VOXEL_BINS_R*1.0)));
      sprintf(hname,"angleMapSeg%ir%ito%i",k,rValMin,rValMax);
      if((angleMap[k*VOXEL_BINS_R + j] = (TH1*)inp->Get(hname))==NULL){
        cout << "No angle coordinate map for segment " << k << ", radial bin " << j << endl;
      }
      Int_t numAngleBins = getNumAngleBins(j,1.0);
      for(int i = 0; i < numAngleBins; i++){
        Int_t angleValMin = (Int_t)(i*(MAX_VAL_ANGLE/(numAngleBins*1.0))); //size of phi bins depends on r
        Int_t angleValMax = (Int_t)((i+1)*(MAX_VAL_ANGLE/(numAngleBins*1.0))); //size of phi bins depends on r
        sprintf(hname,"zMapSeg%ir%ito%iangle%ito%i",k,rValMin,rValMax,angleValMin,angleValMax);
        if((zMap[k*(VOXEL_BINS_ANGLE_MAX)*(VOXEL_BINS_R) + j*VOXEL_BINS_ANGLE_MAX + i] = (TH1*)inp->Get(hname))==NULL){
          zMap[k*(VOXEL_BINS_ANGLE_MAX)*(VOXEL_BINS_R) + j*VOXEL_BINS_ANGLE_MAX + i]=NULL;
          cout << "No z coordinate map for segment " << k << ", radial bin " << j << ", angle bin " << i << ", name: " << hname << endl;
        }
      }
    } 
  }

  cout << "Map file data read in." << endl;

  pos3DMap = new TH3D("pos3DMap","pos3DMap",40,-40,40,40,-40,40,40,-10,100);
  list->Add(pos3DMap);

  //setup histograms for the mapped parameters
  for(int k = 0; k < NSEG; k++){
    sprintf(hname,"rMappedSeg%i",k);
    rMappedHist[k] = new TH1D(hname,Form("rMappedSeg%i",k),40,0,40);
    list->Add(rMappedHist[k]);
    sprintf(hname,"angleMappedSeg%i",k);
    angleMappedHist[k] = new TH1D(hname,Form("angleMappedSeg%i",k),30,0,90);
    list->Add(angleMappedHist[k]);
    sprintf(hname,"zMappedSeg%i",k);
    zMappedHist[k] = new TH1D(hname,Form("zMappedSeg%i",k),90,0,90);
    list->Add(zMappedHist[k]);
  }

  if(inpList){
    FILE *listFile;
    char name[256];
    if((listFile=fopen(infile,"r"))==NULL){
      cout << "ERROR: Could not open analysis tree list file!" << endl;
      exit(-1);
    }
    while(fscanf(listFile,"%s",name)!=EOF){
      TFile * inputfile = new TFile(name, "READ");
      if (!inputfile->IsOpen()) {
        cout << "ERROR: Could not open analysis tree file (" << name << ")" << endl;
        exit(-1);
      }
      sortData(inputfile, calfile);
      inputfile->Close();
    }
    fclose(listFile);
  }else{
    TFile * inputfile = new TFile(infile, "READ");
    if (!inputfile->IsOpen()) {
      cout << "ERROR: Could not open analysis tree file (" << infile << ")" << endl;
      exit(-1);
    }
    sortData(inputfile, calfile);
    inputfile->Close();
  }
  

  cout << "Writing histograms to: " << outfile << endl;
  TFile * myfile = new TFile(outfile, "RECREATE");
  myfile->cd();
  list->Write();
  cout << "Histograms written, sorting complete!" << endl;
  myfile->Close();
  inp->Close();
}

int main(int argc, char ** argv) {

  const char *afile, *mapfile, *outfile, *calfile;
  char *ext;

  if (argc < 2) {
    cout << endl << "This sortcode sorts resconstructed hit positions, using the map file generated using the GammaTrackingMakeMap code.  ";
    cout << "It is only suitable for events containing a single interaction in a single segment, use the GammaTrackingSortFromBasis code otherwise." << endl << endl;
    cout << "Arguments: ./GammaTrackingSortExample analysis_tree_file map_file cal_file output_file" << endl << endl;
    cout << "The analysis tree (containing the experimental data to be sorted) is a required argument.  Omitting other arguments will cause the sortcode to fall back to default values." << endl << endl;
	  return 0;
  } else if (argc == 2) {
	  afile = argv[1];
    mapfile = "trackingMap.root";
	  calfile = "CalibrationFile.cal";
	  outfile = "trackingSortTest.root";
  } else if (argc == 3) {
	  afile = argv[1];
    mapfile = argv[2];
	  calfile = "CalibrationFile.cal";
	  outfile = "trackingSortTest.root";
  } else if (argc == 4) {
	  afile = argv[1];
    mapfile = argv[2];
	  calfile = argv[3];
	  outfile = "trackingSortTest.root";
  } else if (argc == 5) {
	  afile = argv[1];
    mapfile = argv[2];
	  calfile = argv[3];
	  outfile = argv[4];
  } else if (argc > 5) {
	  cout << "Too many arguments." << endl;
    cout << "Arguments: ./GammaTrackingSortExample analysis_tree_file map_file cal_file output_file" << endl;
	  return 0;
  }

  cout << "Starting sortcode..." << endl;

  std::string grsi_path = getenv("GRSISYS"); // Finds the GRSISYS path to be used by other parts of the grsisort code
  if(grsi_path.length() > 0) {
	  grsi_path += "/";
  }
  // Read in grsirc in the GRSISYS directory to set user defined options on grsisort startup
  grsi_path += ".grsirc";
  gEnv->ReadFile(grsi_path.c_str(), kEnvChange);

  cout << "Input file: " << afile << endl << "Map data file: " << mapfile << endl << "Calibration file: " << calfile << endl << "Output file: " << outfile << endl;

  TParserLibrary::Get()->Load();

  ext=strrchr(argv[1],'.'); /* returns a pointer to the last . to grab extention*/

  if(strcmp(ext,".list")==0){
    cout << "Sorting from a list of analysis trees..." << endl;
    sort_test(afile, mapfile, calfile, outfile, true);
  }else{
    cout << "Sorting from a single analysis tree..." << endl;
    sort_test(afile, mapfile, calfile, outfile, false);
  }

  return 0;
}
